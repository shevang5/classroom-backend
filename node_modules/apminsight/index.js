var dotenv = require("dotenv");
dotenv.config();
var agent = require("./lib/agent");
var utils = require("./lib/util/utils");
var packageJson = require("./package.json");
var path = require("path");
var fs = require("fs");
const constants = require('./lib/constants.js');

var agentInstance;

function includeAgentInfo(options) {
    options = options || {};
    var version = packageJson.version;
    var lastIndex = version.lastIndexOf(".");
    options.agentVersion = version.substring(0, lastIndex);
    options.agentFullVersion = version;
    options.agentInstallPath = __dirname;
}

function AgentAPI() {
    if (
        process.env.APMINSIGHT_AGENT_DISABLE &&
        process.env.APMINSIGHT_AGENT_DISABLE.toLowerCase() == "true"
    ) {
        process.stdout.write("\n[APM] Apminsight agent is disabled.\n");
        return;
    }
    if (!agentInstance) {
        var options = readInfoFromFile();
        includeAgentInfo(options);
        agent.init(options);
        agentInstance = global.apmInsightAgentInstance;
    }
    return AgentAPI;
}

AgentAPI();

AgentAPI.config = function () {
    if (process.env.APMINSIGHT_AGENT_DISABLE) {
        process.stdout.write("\n[APM] Apminsight agent is disabled.\n");
        return;
    }
    if (!agentInstance) {
        var config = readInfoFromFile();
        includeAgentInfo(config);
        agent.init(config);
        agentInstance = global.apmInsightAgentInstance;
    }
};

AgentAPI.startWebTransaction = function (txnName, func) {
    if (!agentInstance) {
        return func();
    }
    apmInsightAgentInstance.startApiTransaction(txnName, func, false);
};

AgentAPI.startBackgroundTransaction = function (txnName, func) {
    if (!agentInstance) {
        return func();
    }
    apmInsightAgentInstance.startApiTransaction(txnName, func, true);
};

AgentAPI.endTransaction = function (err) {
    agentInstance && apmInsightAgentInstance.endApiTxn(err);
};

AgentAPI.startTracker = function (trackerName, componentName, handler, cb) {
    if (!agentInstance) {
        return handler();
    }
    apmInsightAgentInstance.createCustomTracker(
        trackerName,
        componentName,
        handler,
        cb
    );
};

AgentAPI.trackError = function (err) {
    agentInstance && apmInsightAgentInstance.trackError(err);
};

AgentAPI.setTransactionName = function (name) {
    if (agentInstance && utils.isNonEmptyString(name)) {
        apmInsightAgentInstance.setTransactionName(name);
    }
};

AgentAPI.addParameter = function (key, value) {
    if (agentInstance && utils.isNonEmptyString(key)) {
        agentInstance.addParameter(key, value);
    }
};

AgentAPI.ignoreCurrentTransaction = function () {
    agentInstance && apmInsightAgentInstance.ignoreCurTxn();
};

AgentAPI.incrementCustomMetric = function (metricName, incrValue) {
    agentInstance &&
        apmInsightAgentInstance.incrementCustomMetric(metricName, incrValue);
};

AgentAPI.averageCustomMetric = function (metricName, metricValue) {
    agentInstance &&
        apmInsightAgentInstance.averageCustomMetric(metricName, metricValue);
};

AgentAPI.getRumScript = function () {
    return apmInsightAgentInstance.getRumScript();
};

AgentAPI.instrumentWebFramework = function (moduleName, moduleInfo) {
    agentInstance &&
        apmInsightAgentInstance.instrumentingWebFramework(
            moduleName,
            moduleInfo
        );
};

function readInfoFromFile() {
    var options = {};
    if(process.env.APMINSIGHT_AUTOPROFILER_CONF_FILEPATH && fs.existsSync(process.env.APMINSIGHT_AUTOPROFILER_CONF_FILEPATH)){
        try{
            let oneAgentData = utils.parseIniFile(process.env.APMINSIGHT_AUTOPROFILER_CONF_FILEPATH);
            if(!utils.isEmpty(oneAgentData)){
                let oneAgentSectionInfo = oneAgentData[constants.oneAgentSectionInfo];
                const encryptedLicenseKey = oneAgentSectionInfo[constants.oneAgentLicenseKey];
                const iV = oneAgentSectionInfo[constants.oneAgentIV];
                const saltKey = oneAgentSectionInfo[constants.oneAgentSaltKey];
                const serverMonitorKey = oneAgentSectionInfo[constants.oneAgentServerMonitorKey];
                const decryptedLicenseKey = encryptedLicenseKey && saltKey && iV && utils.toDecryptKey(encryptedLicenseKey, saltKey, iV);
                if(!utils.isEmpty(decryptedLicenseKey)){
                    options.licenseKey = encryptedLicenseKey;
                }else{
                    throw new Error('oneagent decryption failed with empty');
                }
                if(!utils.isEmpty(iV)){
                    constants.initVector = iV;
                }
                if(!utils.isEmpty(saltKey)){
                    constants.securitykey = saltKey;
                }
                if(!utils.isEmpty(serverMonitorKey)){
                    options.serverMonitorKey = serverMonitorKey;
                }
                return options;
            }
        }catch(error){
            //continuing with normal flow
            options = {};
        }
    }

    var agentInfoPath = path.join(process.cwd(), "apminsightnode.json");
    if (fs.existsSync(agentInfoPath)) {
        try {
            var agentData = fs.readFileSync(agentInfoPath, {
                encoding: "utf8",
                flag: "r"
            });
            if (utils.isEmpty(agentData)) {
                utils
                    .writeStream()
                    .write("[APM] apminsightnode.json file is empty.\n");
            } else {
                options = JSON.parse(agentData);
                var encryptedData = getEncryptedKey(options);
                if (!utils.isBoolean(encryptedData)) {
                    //Replacing the licenseKey with encrypted data
                    options.licenseKey = encryptedData;
                    //Serialize as JSON and Write it to the file
                    try {
                        fs.writeFileSync(
                            agentInfoPath,
                            JSON.stringify(options)
                        );
                    } catch (err) {}
                }
            }
            options.agentInfoPath = agentInfoPath;
            return options;
        } catch (err) {
            utils
                .writeStream()
                .write(
                    "[APM] Error while reading the apminsightnode.json file :: " +
                        err +
                        "\n"
                );
            return options;
        }
    } else {
        if (
            !(
                process.env.APMINSIGHT_LICENSE_KEY &&
                process.env.APMINSIGHT_APP_NAME
            )
        ) {
            utils
                .writeStream()
                .write(
                    "[APM] This version of APM Insight Node.js Agent requires creation of a configuration file (apminsightnode.json) in " +
                        process.cwd() +
                        " or Use of Environment variables. Please refer the help docs for more information.\n"
                );
        }
        return options;
    }
}

function getEncryptedKey(options) {
    //decryption is necessary to avoid encryption on already encrypted data
    var decryptedData = utils.toDecryptKey(options.licenseKey);
    if (utils.isBoolean(decryptedData)) {
        var encryptedData = utils.toEncryptKey(options.licenseKey);
        return encryptedData;
    } else {
        return false;
    }
}

module.exports = AgentAPI;
