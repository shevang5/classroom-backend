const v8 = require("v8"); //No I18N
let time, cpuUsage;

// Interacts with the native site24x7 module to fetch garbage collection stats & eventloop stats
function captureNativeMetrics() {
    try {
        var nativeStats = require("@apminsight/native-stats"); //No I18N
    } catch (e) {
        return;
    }
    if (nativeStats) {
        return nativeStats.getStats();
    }
}
// Captures memory usage metrics for the v8.
/**
 * Metric inference
 * non_heap : The memory allocated to data outside V8's heap (for example, buffers, sockets).
 * heap_used : The amount of memory being used by V8 (for example, JavaScript objects).
 * heap_free : The amount of memory set aside by V8 for memory pooling. This memory isn't being actively used, but is set aside for V8 to freely allocate more as needed.
 **/

function captureMemoryUsageMetrics() {
    if (!process.memoryUsage()) return;
    const memoryUsage = process.memoryUsage();
    var memoryData = {};
    memoryData.heap_total = memoryUsage.heapTotal;
    memoryData.heap_used = memoryUsage.heapUsed;
    var heapFree = memoryUsage.heapTotal - memoryUsage.heapUsed;
    memoryData.heap_free = heapFree > 0 ? heapFree : 0;
    var nonHeap = memoryUsage.rss - memoryUsage.heapTotal;
    memoryData.non_heap = nonHeap > 0 ? nonHeap : 0;
    return memoryData;
}

// Captures heap stats for the application.
// Currently not used in the client , will be useful in the future for memory leak detection .

function captureHeapMetrics() {
    const heapStats = v8.getHeapStatistics();
    let heapMetrics = {
        total_heap_size: heapStats.total_heap_size, //No I18N
        total_heap_size_executable: heapStats.total_heap_size_executable, //No I18N
        total_physical_size: heapStats.total_physical_size, //No I18N
        total_available_size: heapStats.total_available_size, //No I18N
        heap_size_limit: heapStats.heap_size_limit //No I18N
    };
    if (heapStats.malloced_memory) {
        heapMetrics.malloced_memory = heapStats.malloced_memory;
    }
    if (heapStats.peak_malloced_memory) {
        heapMetrics.peak_malloced_memory = heapStats.peak_malloced_memory;
    }
    return heapMetrics;
}
// Captures heapspace stats for the application.
// Currently not used in the client , will be useful in the future for memory leak detection.
function captureHeapSpaceMetrics() {
    if (!v8.getHeapSpaceStatistics) return;
    const stats = v8.getHeapSpaceStatistics();
    let metrics = {};
    for (let i = 0, l = stats.length; i < l; i++) {
        metrics[stats[i].space_name] = {
            space_size: stats[i].space_size,
            space_used_size: stats[i].space_used_size,
            space_available_size: stats[i].space_available_size,
            physical_space_size: stats[i].physical_space_size
        };
    }
    return metrics;
}
//Captures CPU Usage Metrics of the Node Process.
/**
 * Metric inference
 * user : The time spent executing the user code, divided by wall-clock time.
 * system : The time spent in the system kernel on behalf of the Node process, divided by wall-clock time.
 * total : user+system.
 **/
function captureCpuUsageMetrics() {
    if (!process.cpuUsage) return;

    const elapsedTime = process.hrtime(time);
    const elapsedUsage = process.cpuUsage(cpuUsage);

    time = process.hrtime();
    cpuUsage = process.cpuUsage();

    const elapsedMs = elapsedTime[0] * 1000 + elapsedTime[1] / 1000000;
    const userPercent = (100 * elapsedUsage.user) / 1000 / elapsedMs;
    const systemPercent = (100 * elapsedUsage.system) / 1000 / elapsedMs;
    const totalPercent = userPercent + systemPercent;

    let cpuStats = {
        system: systemPercent.toFixed(2), //No I18N
        user: userPercent.toFixed(2), //No I18N
        total: totalPercent.toFixed(2) //No I18N
    };
    return cpuStats;
}

function getNvmStats() {
    var data = {};
    Object.assign(data, captureNativeMetrics());
    data.memory_usage = captureMemoryUsageMetrics();
    data.cpu_usage = captureCpuUsageMetrics();
    data.ct = new Date().getTime();
    return data;
}

module.exports = {
    getNodeVMStats: getNvmStats
};
