// supported upto v2.15.0

var constants = require("./../../constants");
var wrapper = require("./../wrapper");
var utils = require("./../../util/utils");

var moduleInfo = {
    functions: [
        {
            functionName: "createConnection",
            wrapper: wrapConnection,
            component: "MYSQL"
        },
        {
            functionName: "createPool",
            wrapper: wrapPool,
            component: "MYSQL"
        },
        {
            functionName: "createPoolCluster",
            wrapper: wrapPoolCluster,
            component: "MYSQL"
        },
        {
            functionName: "Client.prototype.connect",
            component: "MYSQL"
        },
        {
            functionName: "Client.prototype.query",
            component: "MYSQL",
            extractInfo: getQuery,
            trackerType: constants.dbTracker
        },
        {
            functionName: "Client.prototype._connect",
            component: "MYSQL"
        }
    ]
};

var connectionInfo = [
    {
        functionName: "query",
        component: "MYSQL",
        extractInfo: getQuery,
        trackerType: constants.dbTracker
    },
    {
        functionName: "connect",
        component: "MYSQL",
        extractInfo: getRemoteHost
    },
    {
        functionName: "changeUser",
        component: "MYSQL"
    },
    {
        functionName: "beginTransaction",
        component: "POJSO"
    },
    {
        functionName: "commit",
        component: "MYSQL"
    },
    {
        functionName: "rollback",
        component: "POJSO"
    },
    {
        functionName: "ping",
        component: "MYSQL"
    },
    {
        functionName: "end",
        component: "MYSQL"
    }
];

var poolInfo = [
    {
        functionName: "getConnection",
        component: "MYSQL"
    },
    {
        functionName: "acquireConnection",
        component: "POJSO"
    },
    {
        functionName: "end",
        component: "MYSQL"
    },
    {
        functionName: "query",
        component: "MYSQL"
    }
];

var poolClusterInfo = [
    {
        functionName: "add",
        wrapper: wrapPoolClusterAdd,
        component: "MYSQL"
    },
    {
        functionName: "getConnection",
        component: "MYSQL"
    }
];

function wrapConnection(actual) {
    return function () {
        var conn = actual.apply(this, arguments);
        checkAndInstrument(conn, connectionInfo);
        return conn;
    };
}

function wrapPool(actual) {
    return function () {
        var pool = actual.apply(this, arguments);
        checkAndInstrument(pool, poolInfo);
        checkAndInstrumentPoolObject(pool);
        return pool;
    };
}

function checkAndInstrumentPoolObject(pool) {
    if (pool && utils.isFunction(pool.on)) {
        if (!pool.apmInsightAgentInstrumented) {
            pool.on("connection", function (conn) {
                checkAndInstrument(conn, connectionInfo);
            });
            pool.apmInsightAgentInstrumented = true;
        }
    }
}

function wrapPoolCluster(actual) {
    return function () {
        var poolCluster = actual.apply(this, arguments);
        checkAndInstrument(poolCluster, poolClusterInfo);
        return poolCluster;
    };
}

function wrapPoolClusterAdd(actual) {
    return function () {
        var result = actual.apply(this, arguments);
        // NOTE : Object internal variable _nodes is used here
        // If it changed in mysql module then need to handle modification
        if (utils.isObject(this._nodes)) {
            var nodes = this._nodes;
            Object.keys(nodes).forEach(function (eachNode) {
                if (utils.isObject(nodes[eachNode])) {
                    checkAndInstrumentPoolObject(nodes[eachNode].pool);
                }
            });
        }
        return result;
    };
}

function checkAndInstrument(result, moduleInfo) {
    if (!result) {
        return;
    }
    moduleInfo.forEach(function (eachFunctionInfo) {
        wrapper.checkAndWrapFunction(
            result,
            eachFunctionInfo,
            "mysql",
            eachFunctionInfo.functionName
        );
    });
}

function getRemoteHost(invoker, params, returnObj, tracker) {
    if (!invoker) {
        return;
    }
    var info = {};
    if (invoker.host && invoker.port) {
        info.host = invoker.host;
        info.port = invoker.port;
    }
    var config = invoker.config;
    if (config && config.host && config.port) {
        info.host = config.host;
        info.port = config.port;
    } else if (
        config.connectionConfig &&
        config.connectionConfig.host &&
        config.connectionConfig.port
    ) {
        info.host = config.connectionConfig.host;
        info.port = config.connectionConfig.port;
    }
    tracker.updateInfo(info);
}

function getQuery(invoker, params, query, tracker, asynOpnInfo) {
    getRemoteHost(invoker, params, query, tracker);
    let isSqlCaptureEnabled = apmInsightAgentInstance.getConfig().isDataExporterEnabled();
    if (!isSqlCaptureEnabled) {
        let txn = asynOpnInfo && asynOpnInfo.curTxn;
        const threshold = txn ? utils.getGenericThreshold(txn.getUrl()) : apmInsightAgentInstance.getThreshold();
        isSqlCaptureEnabled = threshold.isSqlCaptureEnabled();
    }
    var info = {};
    if (isSqlCaptureEnabled && params && params.length > 0) {
        var queryInfo = params[0];
        if (typeof queryInfo === "string") {
            info.query = queryInfo;
        } else if (typeof queryInfo === "object") {
            info.query = queryInfo.sql;
        }
    }
    // callback is fetched and instrumentred from query object
    if (query && utils.isFunction(query._callback)) {
        var curTxn = apmInsightAgentInstance.getCurTxn();
        query._callback = wrapper.wrapCallBack(
            query._callback,
            tracker,
            curTxn
        );
    }
    tracker.updateInfo(info);
}

module.exports = moduleInfo;
