// supported from 1.0.0 to 3.5.0

var wrapper = require("./../wrapper");
var utils = require("./../../util/utils");

var component = "CASSANDRA";

var moduleInfo = {
    functions: [
        {
            functionName: "Client.prototype._innerExecute",
            wrapper: executeWrapper,
            component: component
        },
        {
            functionName: [
                "Client.prototype.connect",
                "Client.prototype.shutdown",
                "Client.prototype.batch"
            ],
            component: component
        }
    ]
};

function executeWrapper(actualCaller) {
    return function () {
        var curTxn = apmInsightAgentInstance.getCurTxn();
        var parentTracker = apmInsightAgentInstance.getCurTracker();
        if (!curTxn || curTxn.isCompleted()) {
            return actualCaller.apply(this, arguments);
        }
        var result;
        var cbIndex = wrapper.getCallBackIndex(arguments);
        var trackerInfo = {
            trackerName: "innerExecute",
            component: component,
            isDbTracker: true,
            parent: parentTracker
        };
        var track = apmInsightAgentInstance.createTracker(trackerInfo);
        let isSqlCaptureEnabled = apmInsightAgentInstance.getConfig().isDataExporterEnabled();
        if (!isSqlCaptureEnabled) {
            const th = utils.getGenericThreshold(curTxn.getUrl());
            isSqlCaptureEnabled = th.isSqlCaptureEnabled();
        }

        if (isSqlCaptureEnabled &&
            track &&
            typeof arguments[0] === "string"
        ) {
            var info = {};
            info.query = arguments[0];
            track.updateInfo(info);
        }
        try {
            if (cbIndex > 0) {
                arguments[cbIndex] = wrapExecuteCb(
                    arguments[cbIndex],
                    track,
                    curTxn
                );
                result = actualCaller.apply(this, arguments);
            } else {
                result = actualCaller.apply(this, arguments);
                result = wrapper.checkAndWrapPromise(result, curTxn, track);
            }
        } catch (e) {
            apmInsightAgentInstance.handleErrorTracker(track, e);
            throw e;
        } finally {
            apmInsightAgentInstance.setCurTracker(parentTracker);
        }
        return result;
    };
}

function wrapExecuteCb(cb, curTracker, txn) {
    return function (err, results) {
        if (!txn || txn.isCompleted()) {
            return cb.apply(this, arguments);
        }
        parseCbArgs(err, results, curTracker, txn);
        var CallbackName = utils.isEmpty(cb.name) ? "Anonymous" : cb.name;
        var trackerInfo = {
            trackerName: "Callback:" + CallbackName,
            component: component,
            sync: true
        };
        var syncOpnInfo = {
            txn: txn,
            asyncParentTracker: curTracker,
            trackerInfo: trackerInfo
        };
        return wrapper.invokeSyncOpn(cb, this, arguments, syncOpnInfo);
    };
}

function parseCbArgs(err, results, tracker, txn) {
    if (!tracker) {
        return;
    }
    if (err && err instanceof Error) {
        tracker.setError(err, txn);
        extractHostInfo(err.coordinator, tracker);
    } else if (results && results.info) {
        extractHostInfo(results.info.queriedHost, tracker);
    }
}

function extractHostInfo(hostInfo, tracker) {
    if (hostInfo && typeof hostInfo === "string" && hostInfo.indexOf(":") > 0) {
        var details = hostInfo.split(":");
        if (details && details.length > 1) {
            var info = {};
            info.host = details[0];
            info.port = details[1];
            tracker.updateInfo(info);
        }
    }
}

module.exports = moduleInfo;
