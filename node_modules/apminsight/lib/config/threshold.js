var constants = require("./../constants");
var defaults = require("./default");
var utils = require("./../util/utils");
const logger = require("../util/logger");

var thresholdConversion = {};
thresholdConversion[constants.traceThresholdKey] = convertToMillis;
thresholdConversion[constants.bgTxnTraceThKey] = convertToMillis;

function convertToMillis(seconds) {
    return seconds * 1000;
}

function Threshold() {
    this._thresholdMap = defaults;
    this._lastModified = null;
}

Threshold.prototype.update = function (customConfig, agentSpecific) {
    customConfig = customConfig || {};
    agentSpecific = agentSpecific || {};
    this._thresholdMap = Object.assign(this._thresholdMap, customConfig);
    this._thresholdMap = Object.assign(this._thresholdMap, agentSpecific);
    this.applyConversion();
    this.updateSkipTxnListening(agentSpecific[constants.txnSkipListeningKey]);
    this.updateSkipTxnList(agentSpecific[constants.txnSkip]);
    this.updateTxnGrouping(agentSpecific[constants.txnGrouping]);
};

Threshold.prototype.getApdexTh = function () {
    return this._thresholdMap[constants.apdexThKey];
};

Threshold.prototype.isSqlCaptureEnabled = function () {
    return this._thresholdMap[constants.sqlCaptureKey];
};

Threshold.prototype.getWebTxnSamplingFactor = function () {
    return this._thresholdMap[constants.webTxnsamplingFactorKey];
};

Threshold.prototype.getBgTxnSamplingFactor = function () {
    return this._thresholdMap[constants.bgTxnSamplingFactorKey];
};

Threshold.prototype.getTraceThreshold = function () {
    return this._thresholdMap[constants.traceThresholdKey];
};

Threshold.prototype.getSqlTraceThreshold = function () {
    return this._thresholdMap[constants.sqlStracktraceKey];
};

Threshold.prototype.isSqlParameterized = function () {
    return this._thresholdMap[constants.sqlParametrizeKey];
};

Threshold.prototype.getLastModified = function () {
    return this._thresholdMap[constants.lastModifiedTimeKey];
};

Threshold.prototype.getApdexMetricSize = function () {
    return this._thresholdMap[constants.apdexMetricKey];
};

Threshold.prototype.getDbMetricSize = function () {
    return this._thresholdMap[constants.dbMetricKey];
};

Threshold.prototype.getBgMetricSize = function () {
    return this._thresholdMap[constants.bgMetricKey];
};

Threshold.prototype.getTraceMetricSize = function () {
    return this._thresholdMap[constants.traceMetricKey];
};

Threshold.prototype.getKeyTxnList = function () {
    var keyTxnList = this._thresholdMap[constants.keyTxnList].split(",");
    return keyTxnList;
};

Threshold.prototype.getLogLevel = function () {
    return this._thresholdMap[constants.logLevel];
};

Threshold.prototype.getSkipTxnListening = function () {
    return this._thresholdMap[constants.txnSkipListeningKey];
};

Threshold.prototype.getSkipTxnList = function () {
    return this._thresholdMap[constants.txnSkip];
};

Threshold.prototype.getTxnGroupingList = function () {
    return this._thresholdMap[constants.txnGrouping];
};

Threshold.prototype.getTxnTrackerDropThreshold = function () {
    return this._thresholdMap[constants.txnTrackerDropThKey];
};

Threshold.prototype.getTxnTraceExtCallThreshold = function () {
    return this._thresholdMap[constants.txnTraceExtCountThKey];
};

Threshold.prototype.getHttpErrorCodesIgnoreList = function () {
    let httpErrorcodesList = [];
    try {
        const value = this._thresholdMap[constants.httpErrorCodesIgnore] || ""; // Default to empty string if undefined
        httpErrorcodesList = value
            .split(",")
            .map(code => code.trim()) // Remove extra spaces
            .filter(code => code !== ""); // Remove empty values
    } catch (err) {
        logger.error(
            "Error while processing http error code list. Please enter comma seperated values."
        );
        httpErrorcodesList = [];
    }
    return httpErrorcodesList;
};

Threshold.prototype.getHttpErrorCodesTrackList = function () {
    let httpErrorcodesList = [];
    try {
        const value = this._thresholdMap[constants.httpErrorCodesTrack] || ""; // Default to empty string if undefined
        httpErrorcodesList = value
            .split(",")
            .map(code => code.trim()) // Remove extra spaces
            .filter(code => code !== ""); // Remove empty values
    } catch (err) {
        logger.error(
            "Error while processing HTTP error code include list. Please enter comma-separated values."
        );
        httpErrorcodesList = [];
    }
    return httpErrorcodesList;
};

Threshold.prototype.isBgTxnTrackingEnabled = function () {
    return this._thresholdMap[constants.bgTxnTrackingEnabledKey];
};

Threshold.prototype.isBgTxnTraceEnabled = function () {
    return this._thresholdMap[constants.bgTxnTraceEnabledKey];
};

Threshold.prototype.bgTxnTraceTh = function () {
    return this._thresholdMap[constants.bgTxnTraceThKey];
};

Threshold.prototype.isDistributedTracingEnabled = function () {
    return this._thresholdMap[constants.distributedTracingKey];
};

Threshold.prototype.isCaptureHttpParamsEnabled = function () {
    return this._thresholdMap[constants.captureHttpParams];
};

Threshold.prototype.isCaptureHttpHeadersEnabled = function () {
    return this._thresholdMap[constants.captureHttpHeaders];
};

Threshold.prototype.getRequestHeadersIgnoreList = function () {
    return this._thresholdMap[constants.requestHeadersIgnore];
};

Threshold.prototype.updateSkipTxnListening = function (configuredStr) {
    if (configuredStr === undefined) {
        return;
    }
    configuredStr = configuredStr.replace(/\*|\s/g, "");
    var extArray = configuredStr.split(",");
    this._thresholdMap[constants.txnSkipListeningKey] = extArray;
};

Threshold.prototype.updateSkipTxnList = function (configuredSkipTxnStr) {
    if (utils.isEmpty(configuredSkipTxnStr)) {
        return;
    }
    try {
        configuredSkipTxnStr = configuredSkipTxnStr
            .replace("*", ".*")
            .replace("?", ".");
        var extTxnArray = configuredSkipTxnStr.split(",");
        extTxnArray.forEach(function (element, index) {
            if (element.charAt(0) != "/") {
                extTxnArray[index] = "/" + element;
            }
        });
        this._thresholdMap[constants.txnSkip] = extTxnArray;
    } catch (err) {
        logger.error("Error while updating skip transaction.");
    }
};

Threshold.prototype.updateTxnGrouping = function (txnGrouping) {
    try {
        var configuredTxnGrouping;
        if (!utils.isEmpty(txnGrouping)) {
            var txnGroupingObj = {};
            configuredTxnGrouping = txnGrouping.split("\n");
            configuredTxnGrouping.forEach(function (eachGrouping) {
                var splitGrouping = eachGrouping.split("=");
                txnGroupingObj[splitGrouping[0]] = splitGrouping[1];
            });
            this._thresholdMap[constants.txnGrouping] = txnGroupingObj;
        }
    } catch (err) {
        logger.error("Error while updating transaction grouping.");
    }
};

Threshold.prototype.applyConversion = function () {
    Object.keys(thresholdConversion).forEach(function (eachThreshold) {
        var value = this._thresholdMap[eachThreshold];
        if (value) {
            var conversionFn = thresholdConversion[eachThreshold];
            this._thresholdMap[eachThreshold] = conversionFn(value);
        }
    }, this);
};

Threshold.prototype.isTxnAllowed = function (uri) {
    if (utils.isEmpty(uri)) {
        return false;
    }
    var index = uri.lastIndexOf(".");
    if (index < 0) {
        var isAllowed = true;
        try {
            if (!utils.isEmpty(this.getSkipTxnList())) {
                this.getSkipTxnList().find(function (eachRegex) {
                    //Skip transaction check
                    const regex = new RegExp(eachRegex);
                    var regexMatch = regex.exec(uri);
                    if (!utils.isEmpty(regexMatch)) {
                        isAllowed = false;
                    }
                });
            }
        } catch (err) {
            logger.error(
                "Error while checking " + uri + " is skip transaction."
            );
        }
        return isAllowed;
    }
    var extension = uri.substring(index, uri.length);
    return this.getSkipTxnListening().indexOf(extension) < 0; //Skip URL extension
};

Threshold.prototype.isTxnGroupingConfigured = function (uri) {
    var txnsConfiguredForGrouping = {};
    if (!utils.isEmpty(this.getTxnGroupingList())) {
        txnsConfiguredForGrouping = Object.assign(
            txnsConfiguredForGrouping,
            this.getTxnGroupingList()
        );
    }
    var newGroupingName;
    if (!utils.isEmptyObject(txnsConfiguredForGrouping)) {
        Object.keys(txnsConfiguredForGrouping).find(function (eachKey) {
            const regex = new RegExp(eachKey);
            var regexMatch = regex.exec(uri);
            if (!utils.isEmpty(regexMatch)) {
                newGroupingName = txnsConfiguredForGrouping[eachKey];
                if (newGroupingName.charAt(0) != "/") {
                    newGroupingName = "/" + newGroupingName;
                }
            }
        });
    }
    return newGroupingName;
};

module.exports = Threshold;
